Front,Back
"ğŸ—ï¸ <b>Generic Constraints with <code>keyof</code> in TypeScript</b>","<b>ğŸ§  Emotional Hook:</b> Ever tried asking for 'banana' at a burger joint? TypeScript wonâ€™t let you do that with objects â€” thanks to <code>keyof</code>! ğŸ”ğŸŒ<br><br><b>ğŸ“˜ Definition:</b> The <code>keyof</code> operator gets a union type of all property names in an object. Used in generic constraints, it ensures only valid keys can be accessed safely.<br><br><b>ğŸ”„ Analogy:</b><br>1. Like a vending machine â€” you can only press buttons that exist (A1, B2... not Z9!)<br>2. Like a hotel keycard â€” it only opens rooms assigned to you.<br>3. Like choosing from a dropdown menu â€” options come from whatâ€™s available, not made-up ones.<br><br><b>ğŸ’» Example Code:</b><br>```ts<br>const getPropertyValue = <X, Y extends keyof X>(obj: X, key: Y) => {<br>  return obj[key];<br>};<br><br>const user = {<br>  name: 'Alice',<br>  age: 30,<br>  city: 'Wonderland'<br>};<br><br>const value = getPropertyValue(user, 'name'); // âœ… 'Alice'<br><br>// âŒ Error: 'nickname' is not a key of user<br>// const wrong = getPropertyValue(user, 'nickname');<br>```<br><br><b>ğŸ¯ Why It Matters:</b><br>Using <code>keyof</code> with generics gives you autocompletion, type-safety, and prevents hard-to-find bugs when accessing object properties dynamically."
Front,Back
"â³ <b>Async/Await with Typed Promises in TypeScript</b>","<b>ğŸ§  Emotional Hook:</b> Ever ordered food online and waited patiently for it to arrive? Thatâ€™s async/await! ğŸ• Your program says: â€œIâ€™ll wait for it â€” but meanwhile, keep life going.â€<br><br><b>ğŸ“˜ Definition:</b> <code>async/await</code> is a modern syntax to handle Promises. You define the shape of the expected data using <code>Promise<Type></code> to ensure type-safe results.<br><br><b>ğŸ”„ Analogy:</b><br>1. Like waiting at a restaurant: You order (<code>fetch()</code>), wait (<code>await</code>), and then get food (<code>return</code>).<br>2. Like Amazon delivery: You place the order (async call), then chill while tracking it!<br>3. Like calling a friend and waiting for a reply before replying to someone else.<br><br><b>ğŸ’» Example Code:</b><br>```ts<br>type Todo = {<br>  id: number;<br>  userId: number;<br>  title: string;<br>  completed: boolean;<br>};<br><br>const getTodo = async (): Promise<Todo> => {<br>  const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');<br>  const data = await response.json();<br>  return data;<br>};<br><br>getTodo().then(todo => console.log(todo.title));<br><br>// Simulating your own async function<br>type Something = { something: string };<br><br>const createPromise = (): Promise<Something> => {<br>  return new Promise((resolve, reject) => {<br>    const data = { something: 'Hello Async!' };<br>    data ? resolve(data) : reject('Error fetching data');<br>  });<br>};<br><br>const showData = async (): Promise<Something> => {<br>  const data = await createPromise();<br>  return data;<br>};<br><br>showData().then(d => console.log(d.something));<br>```<br><br><b>ğŸ¯ Why It Matters:</b><br>This makes working with asynchronous code easy to read, safe to write, and powerful to debug. Type safety ensures you know exactly what kind of data you're dealing with!"
Front,Back
"ğŸ§  <b>Conditional Types in TypeScript</b>","<b>ğŸ§  Emotional Hook:</b> Imagine being a bouncer at a club, deciding who gets in based on age. Thatâ€™s what TypeScript does with conditional types! ğŸ•ºğŸš«<br><br><b>ğŸ“˜ Definition:</b> A conditional type chooses one type or another depending on a condition. It follows the format: <code>SomeType extends AnotherType ? TrueType : FalseType</code><br><br><b>ğŸ”„ Analogy:</b><br>1. Like an if-else decision made by the type system.<br>2. Like a flowchart for types â€” â€œif this, then that.â€<br>3. Like Google Maps recalculating your route based on traffic.<br><br><b>ğŸ’» Example Code:</b><br>```ts<br>type A = number;<br>type B = string;<br><br>// Simple conditional type<br>type IsNull = A extends null ? true : false; // false<br><br>// Nested conditional type<br>type Result = A extends null ? true : B extends undefined ? undefined : any;<br><br>// Practical example with keyof + conditional<br>type Sheikh = {<br>  bike: string;<br>  car: string;<br>  ship: string;<br>  plane: string;<br>};<br><br>type CheckVehicle<T> = T extends keyof Sheikh ? true : false;<br><br>type HasBike = CheckVehicle<'bike'>;   // true<br>type HasTractor = CheckVehicle<'tractor'>; // false<br>```<br><br><b>ğŸ¯ Why It Matters:</b><br>Conditional types let you write logic *with types themselves*. Itâ€™s like giving your types brains â€” they think and decide things based on the conditions you set!"
Front,Back
"ğŸ” <b>Mapped Types in TypeScript</b>","<b>ğŸ§  Emotional Hook:</b> Imagine cloning your wardrobe but magically changing the color of every item â€” mapped types let you do that, but with types! ğŸ§¥â¡ğŸŒˆ<br><br><b>ğŸ“˜ Definition:</b> A mapped type lets you create new types by looping over properties of an existing type (usually using <code>keyof</code>).<br><br><b>ğŸ”„ Analogy:</b><br>1. Like using a cookie cutter (template) to shape a new batch of cookies from dough (type).<br>2. Like applying a filter to every item in a list â€” but for properties of a type.<br>3. Like customizing uniforms for each role in a company â€” same base, different label.<br><br><b>ğŸ’» Code Example:</b><br>```ts<br>// A base type<br>type AreaNumber = {<br>  height: number;<br>  width: number;<br>};<br><br>// Lookup type<br>type Height = AreaNumber['height']; // number<br><br>// Custom mapped type (generic)<br>type AreaString<T> = {<br>  [key in keyof T]: T[key]; // You could also modify T[key] here (e.g., to string)<br>};<br><br>// Using mapped type<br>const area1: AreaString<{ height: string; width: number }> = {<br>  height: '100',<br>  width: 50<br>};<br><br>// Real-world array transformation<br>const arrOfNumbers: number[] = [1, 4, 5];<br>const arrOfStrings: string[] = arrOfNumbers.map(num => num.toString());<br>console.log(arrOfStrings); // ['1', '4', '5']<br>```<br><br><b>ğŸ¯ Why It Matters:</b><br>Mapped types help you build flexible, reusable type templates. You can iterate over properties, transform types, and create consistent shapes â€” like code automation for your types!"
Front,Back
"ğŸ¯ <b>Pick Utility Type</b>","<b>ğŸ§  Emotional Hook:</b> Imagine you're filling out a form and only need your name and age â€” no distractions! That's what <code>Pick</code> does.<br><br><b>ğŸ“˜ Definition:</b> <code>Pick<Type, Keys></code> creates a new type by choosing specific properties from another type.<br><br><b>ğŸ’» Example:</b><br>```ts<br>type Person = { name: string; age: number; email?: string; contactNo: string };<br>type NameAge = Pick<Person, 'name' | 'age'>;<br>```<br><br><b>ğŸ”„ Analogy:</b><br>Like ordering Ã  la carte from a menu â€” just the items you want."
"âŒ <b>Omit Utility Type</b>","<b>ğŸ§  Emotional Hook:</b> Donâ€™t want anchovies on your pizza? <code>Omit</code> lets you remove toppings (properties) you don't need! ğŸ•<br><br><b>ğŸ“˜ Definition:</b> <code>Omit<Type, Keys></code> constructs a new type by removing specific keys from an existing one.<br><br><b>ğŸ’» Example:</b><br>```ts<br>type ContactInfo = Omit<Person, 'name' | 'age'>;<br>```<br><br><b>ğŸ”„ Analogy:</b><br>Like hiding fields in a form before sharing it with someone."
"âœ… <b>Required Utility Type</b>","<b>ğŸ§  Emotional Hook:</b> It's like your teacher saying: â€œNo excuses, I want every field filled out!â€ âœï¸<br><br><b>ğŸ“˜ Definition:</b> <code>Required<Type></code> makes all properties in a type mandatory (no optional <code>?</code>).<br><br><b>ğŸ’» Example:</b><br>```ts<br>type PersonRequired = Required<Person>;<br>```<br><br><b>ğŸ”„ Analogy:</b><br>Like turning every 'maybe' into a 'must' in a checklist."
"ğŸ§© <b>Partial Utility Type</b>","<b>ğŸ§  Emotional Hook:</b> Feeling lazy? Just fill out what you can â€” thatâ€™s <code>Partial</code> for you! ğŸ›‹ï¸<br><br><b>ğŸ“˜ Definition:</b> <code>Partial<Type></code> makes all properties in a type optional.<br><br><b>ğŸ’» Example:</b><br>```ts<br>type PersonPartial = Partial<Person>;<br>```<br><br><b>ğŸ”„ Analogy:</b><br>Like saving a draft â€” it doesn't have to be complete yet."
"ğŸ›¡ï¸ <b>Readonly Utility Type</b>","<b>ğŸ§  Emotional Hook:</b> Ever wanted to lock a document so no one can change it? Thatâ€™s <code>Readonly</code>! ğŸ”’<br><br><b>ğŸ“˜ Definition:</b> <code>Readonly<Type></code> makes all properties of a type immutable.<br><br><b>ğŸ’» Example:</b><br>```ts<br>type PersonReadonly = Readonly<Person>;<br>const person: PersonReadonly = { name: 'Mr. XY', age: 200, contactNo: '017' };<br>person.name = 'Mr. YZ'; // âŒ Error!<br>```<br><br><b>ğŸ”„ Analogy:</b><br>Like putting your data in a glass case â€” look but donâ€™t touch!"
"ğŸ“š <b>Record Utility Type</b>","<b>ğŸ§  Emotional Hook:</b> What if you could build a dictionary where all keys are known and all values follow a rule? Thatâ€™s <code>Record</code>! ğŸ“–<br><br><b>ğŸ“˜ Definition:</b> <code>Record<Keys, Type></code> creates a new type with keys of a specific type and all values of a specific type.<br><br><b>ğŸ’» Example:</b><br>```ts<br>type MyObj = Record<string, number>;<br>const obj: MyObj = { a: 1, b: 2, c: 3 };<br>```<br><br><b>ğŸ”„ Analogy:</b><br>Like a spreadsheet where every column label is known and every cell must be a number."
