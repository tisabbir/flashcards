Front,Back
"🗝️ <b>Generic Constraints with <code>keyof</code> in TypeScript</b>","<b>🧠 Emotional Hook:</b> Ever tried asking for 'banana' at a burger joint? TypeScript won’t let you do that with objects — thanks to <code>keyof</code>! 🍔🍌<br><br><b>📘 Definition:</b> The <code>keyof</code> operator gets a union type of all property names in an object. Used in generic constraints, it ensures only valid keys can be accessed safely.<br><br><b>🔄 Analogy:</b><br>1. Like a vending machine — you can only press buttons that exist (A1, B2... not Z9!)<br>2. Like a hotel keycard — it only opens rooms assigned to you.<br>3. Like choosing from a dropdown menu — options come from what’s available, not made-up ones.<br><br><b>💻 Example Code:</b><br>```ts<br>const getPropertyValue = <X, Y extends keyof X>(obj: X, key: Y) => {<br>  return obj[key];<br>};<br><br>const user = {<br>  name: 'Alice',<br>  age: 30,<br>  city: 'Wonderland'<br>};<br><br>const value = getPropertyValue(user, 'name'); // ✅ 'Alice'<br><br>// ❌ Error: 'nickname' is not a key of user<br>// const wrong = getPropertyValue(user, 'nickname');<br>```<br><br><b>🎯 Why It Matters:</b><br>Using <code>keyof</code> with generics gives you autocompletion, type-safety, and prevents hard-to-find bugs when accessing object properties dynamically."
Front,Back
"⏳ <b>Async/Await with Typed Promises in TypeScript</b>","<b>🧠 Emotional Hook:</b> Ever ordered food online and waited patiently for it to arrive? That’s async/await! 🍕 Your program says: “I’ll wait for it — but meanwhile, keep life going.”<br><br><b>📘 Definition:</b> <code>async/await</code> is a modern syntax to handle Promises. You define the shape of the expected data using <code>Promise<Type></code> to ensure type-safe results.<br><br><b>🔄 Analogy:</b><br>1. Like waiting at a restaurant: You order (<code>fetch()</code>), wait (<code>await</code>), and then get food (<code>return</code>).<br>2. Like Amazon delivery: You place the order (async call), then chill while tracking it!<br>3. Like calling a friend and waiting for a reply before replying to someone else.<br><br><b>💻 Example Code:</b><br>```ts<br>type Todo = {<br>  id: number;<br>  userId: number;<br>  title: string;<br>  completed: boolean;<br>};<br><br>const getTodo = async (): Promise<Todo> => {<br>  const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');<br>  const data = await response.json();<br>  return data;<br>};<br><br>getTodo().then(todo => console.log(todo.title));<br><br>// Simulating your own async function<br>type Something = { something: string };<br><br>const createPromise = (): Promise<Something> => {<br>  return new Promise((resolve, reject) => {<br>    const data = { something: 'Hello Async!' };<br>    data ? resolve(data) : reject('Error fetching data');<br>  });<br>};<br><br>const showData = async (): Promise<Something> => {<br>  const data = await createPromise();<br>  return data;<br>};<br><br>showData().then(d => console.log(d.something));<br>```<br><br><b>🎯 Why It Matters:</b><br>This makes working with asynchronous code easy to read, safe to write, and powerful to debug. Type safety ensures you know exactly what kind of data you're dealing with!"
Front,Back
"🧠 <b>Conditional Types in TypeScript</b>","<b>🧠 Emotional Hook:</b> Imagine being a bouncer at a club, deciding who gets in based on age. That’s what TypeScript does with conditional types! 🕺🚫<br><br><b>📘 Definition:</b> A conditional type chooses one type or another depending on a condition. It follows the format: <code>SomeType extends AnotherType ? TrueType : FalseType</code><br><br><b>🔄 Analogy:</b><br>1. Like an if-else decision made by the type system.<br>2. Like a flowchart for types — “if this, then that.”<br>3. Like Google Maps recalculating your route based on traffic.<br><br><b>💻 Example Code:</b><br>```ts<br>type A = number;<br>type B = string;<br><br>// Simple conditional type<br>type IsNull = A extends null ? true : false; // false<br><br>// Nested conditional type<br>type Result = A extends null ? true : B extends undefined ? undefined : any;<br><br>// Practical example with keyof + conditional<br>type Sheikh = {<br>  bike: string;<br>  car: string;<br>  ship: string;<br>  plane: string;<br>};<br><br>type CheckVehicle<T> = T extends keyof Sheikh ? true : false;<br><br>type HasBike = CheckVehicle<'bike'>;   // true<br>type HasTractor = CheckVehicle<'tractor'>; // false<br>```<br><br><b>🎯 Why It Matters:</b><br>Conditional types let you write logic *with types themselves*. It’s like giving your types brains — they think and decide things based on the conditions you set!"
Front,Back
"🔁 <b>Mapped Types in TypeScript</b>","<b>🧠 Emotional Hook:</b> Imagine cloning your wardrobe but magically changing the color of every item — mapped types let you do that, but with types! 🧥➡🌈<br><br><b>📘 Definition:</b> A mapped type lets you create new types by looping over properties of an existing type (usually using <code>keyof</code>).<br><br><b>🔄 Analogy:</b><br>1. Like using a cookie cutter (template) to shape a new batch of cookies from dough (type).<br>2. Like applying a filter to every item in a list — but for properties of a type.<br>3. Like customizing uniforms for each role in a company — same base, different label.<br><br><b>💻 Code Example:</b><br>```ts<br>// A base type<br>type AreaNumber = {<br>  height: number;<br>  width: number;<br>};<br><br>// Lookup type<br>type Height = AreaNumber['height']; // number<br><br>// Custom mapped type (generic)<br>type AreaString<T> = {<br>  [key in keyof T]: T[key]; // You could also modify T[key] here (e.g., to string)<br>};<br><br>// Using mapped type<br>const area1: AreaString<{ height: string; width: number }> = {<br>  height: '100',<br>  width: 50<br>};<br><br>// Real-world array transformation<br>const arrOfNumbers: number[] = [1, 4, 5];<br>const arrOfStrings: string[] = arrOfNumbers.map(num => num.toString());<br>console.log(arrOfStrings); // ['1', '4', '5']<br>```<br><br><b>🎯 Why It Matters:</b><br>Mapped types help you build flexible, reusable type templates. You can iterate over properties, transform types, and create consistent shapes — like code automation for your types!"
Front,Back
"🎯 <b>Pick Utility Type</b>","<b>🧠 Emotional Hook:</b> Imagine you're filling out a form and only need your name and age — no distractions! That's what <code>Pick</code> does.<br><br><b>📘 Definition:</b> <code>Pick<Type, Keys></code> creates a new type by choosing specific properties from another type.<br><br><b>💻 Example:</b><br>```ts<br>type Person = { name: string; age: number; email?: string; contactNo: string };<br>type NameAge = Pick<Person, 'name' | 'age'>;<br>```<br><br><b>🔄 Analogy:</b><br>Like ordering à la carte from a menu — just the items you want."
"❌ <b>Omit Utility Type</b>","<b>🧠 Emotional Hook:</b> Don’t want anchovies on your pizza? <code>Omit</code> lets you remove toppings (properties) you don't need! 🍕<br><br><b>📘 Definition:</b> <code>Omit<Type, Keys></code> constructs a new type by removing specific keys from an existing one.<br><br><b>💻 Example:</b><br>```ts<br>type ContactInfo = Omit<Person, 'name' | 'age'>;<br>```<br><br><b>🔄 Analogy:</b><br>Like hiding fields in a form before sharing it with someone."
"✅ <b>Required Utility Type</b>","<b>🧠 Emotional Hook:</b> It's like your teacher saying: “No excuses, I want every field filled out!” ✍️<br><br><b>📘 Definition:</b> <code>Required<Type></code> makes all properties in a type mandatory (no optional <code>?</code>).<br><br><b>💻 Example:</b><br>```ts<br>type PersonRequired = Required<Person>;<br>```<br><br><b>🔄 Analogy:</b><br>Like turning every 'maybe' into a 'must' in a checklist."
"🧩 <b>Partial Utility Type</b>","<b>🧠 Emotional Hook:</b> Feeling lazy? Just fill out what you can — that’s <code>Partial</code> for you! 🛋️<br><br><b>📘 Definition:</b> <code>Partial<Type></code> makes all properties in a type optional.<br><br><b>💻 Example:</b><br>```ts<br>type PersonPartial = Partial<Person>;<br>```<br><br><b>🔄 Analogy:</b><br>Like saving a draft — it doesn't have to be complete yet."
"🛡️ <b>Readonly Utility Type</b>","<b>🧠 Emotional Hook:</b> Ever wanted to lock a document so no one can change it? That’s <code>Readonly</code>! 🔒<br><br><b>📘 Definition:</b> <code>Readonly<Type></code> makes all properties of a type immutable.<br><br><b>💻 Example:</b><br>```ts<br>type PersonReadonly = Readonly<Person>;<br>const person: PersonReadonly = { name: 'Mr. XY', age: 200, contactNo: '017' };<br>person.name = 'Mr. YZ'; // ❌ Error!<br>```<br><br><b>🔄 Analogy:</b><br>Like putting your data in a glass case — look but don’t touch!"
"📚 <b>Record Utility Type</b>","<b>🧠 Emotional Hook:</b> What if you could build a dictionary where all keys are known and all values follow a rule? That’s <code>Record</code>! 📖<br><br><b>📘 Definition:</b> <code>Record<Keys, Type></code> creates a new type with keys of a specific type and all values of a specific type.<br><br><b>💻 Example:</b><br>```ts<br>type MyObj = Record<string, number>;<br>const obj: MyObj = { a: 1, b: 2, c: 3 };<br>```<br><br><b>🔄 Analogy:</b><br>Like a spreadsheet where every column label is known and every cell must be a number."
