🔓 <b>What does the <code>public</code> access modifier mean in a class?</b>,"<b>🧠 Emotional Hook:</b> Imagine a public notice board that everyone can see and write on.<br><br><b>📘 Explanation:</b> Public properties and methods are accessible from anywhere — inside or outside the class.<br><br><b>💻 Example:</b><br>```ts<br>class MyClass {<br>  public name: string = 'Default';<br>}<br><br>const obj = new MyClass();<br>obj.name = 'Hello';<br>console.log(obj.name); // Hello<br>```<br><br><b>🔄 Analogy:</b> Like your phone number you share openly — anyone can reach out."

🔒 <b>What does the <code>private</code> access modifier do?</b>,"<b>🧠 Emotional Hook:</b> Think of a diary locked with a key — only you can open it.<br><br><b>📘 Explanation:</b> Private members can only be accessed within the class they are defined in. Not even subclasses can reach them directly.<br><br><b>💻 Example:</b><br>```ts<br>class MyClass {<br>  private secret: string = 'hidden';<br>}<br><br>const obj = new MyClass();<br>console.log(obj.secret); // ❌ Error: Property 'secret' is private<br>```<br><br><b>🔄 Analogy:</b> Like your bank PIN — even your best friend can’t see it."

🔏 <b>What does <code>readonly</code> do when used with <code>public</code>?</b>,"<b>🧠 Emotional Hook:</b> Like your birth certificate — visible but unchangeable.<br><br><b>📘 Explanation:</b> Readonly properties can be read from anywhere, but cannot be reassigned after the object is initialized.<br><br><b>💻 Example:</b><br>```ts<br>class MyClass {<br>  public readonly id: number;<br><br>  constructor(id: number) {<br>    this.id = id;<br>  }<br>}<br><br>const obj = new MyClass(1);<br>obj.id = 2; // ❌ Error: Cannot assign to 'id' because it is a read-only property<br>```<br><br><b>🔄 Analogy:</b> Like a serial number etched onto your phone — you can read it, but not change it."

💰 <b>Why is <code>_balance</code> private in <code>BankAccount</code>?</b>,"<b>🧠 Emotional Hook:</b> Protecting your money from sneaky changes.<br><br><b>📘 Explanation:</b> By making <code>_balance</code> private, you ensure that only trusted methods within the class can change or read it, helping enforce data integrity.<br><br><b>💻 Example:</b><br>```ts<br>class BankAccount {<br>  private _balance: number = 0;<br><br>  addDeposit(amount: number) {<br>    if (amount > 0) this._balance += amount;<br>  }<br><br>  getBalance(): number {<br>    return this._balance;<br>  }<br>}<br><br>const account = new BankAccount();<br>account.addDeposit(100);<br>console.log(account.getBalance()); // 100<br>```<br><br><b>🔄 Analogy:</b> Like a vault — only trusted procedures can open it."

🎓 <b>Can <code>StudentAccount</code> access <code>_balance</code> directly?</b>,"<b>🧠 Emotional Hook:</b> Like trying to peek into your parent's locked diary — not happening.<br><br><b>📘 Explanation:</b> No, because <code>_balance</code> is private to <code>BankAccount</code>. Even subclasses like <code>StudentAccount</code> can't access it directly.<br><br><b>💻 Example:</b><br>```ts<br>class BankAccount {<br>  private _balance: number = 0;<br><br>  protected getBalance(): number {<br>    return this._balance;<br>  }<br>}<br><br>class StudentAccount extends BankAccount {<br>  showBalance() {<br>    // return this._balance; // ❌ Error: '_balance' is private<br>    return this.getBalance(); // ✅ Allowed via a protected method<br>  }<br>}<br><br>const sa = new StudentAccount();<br>console.log(sa.showBalance());<br>```<br><br><b>🔄 Analogy:</b> You can’t open your parent's locked diary, but they might read from it to you."
"Question","Answer"
"💸 <b>What is a <code>getter</code> in TypeScript?</b>","<b>🧠 Emotional Hook:</b> Ever opened a window just to take a peek outside without changing anything?<br><br><b>📘 Explanation:</b> A getter allows you to access the value of a private or protected property as if it were a normal public property — without exposing the actual property.<br><br><b>💻 Example:</b><br><pre><code>class BankAccount {<br>  // Internal protected balance, not accessible directly from outside<br>  protected _balance: number = 100;<br><br>  // Getter to safely expose the balance value<br>  get balance(): number {<br>    console.log('Getter called: fetching balance...');<br>    return this._balance;<br>  }<br>}<br><br>const acc = new BankAccount();<br>console.log(acc.balance); // Output: Getter called: fetching balance... 100<br><br>// Trying to access _balance directly would cause an error:<br>// console.log(acc._balance); // Error: Property '_balance' is protected</code></pre><br><b>🔄 Analogy:</b> Like a peephole in a door — you can look, but not touch or change anything!"
"🏦 <b>What is a <code>setter</code> in TypeScript?</b>","<b>🧠 Emotional Hook:</b> Imagine you're putting money into a vending machine by simply dropping it in.<br><br><b>📘 Explanation:</b> A setter lets you update a private or protected property from outside the class — with validation or logic if needed — using property-like syntax.<br><br><b>💻 Example:</b><br><pre><code>class BankAccount {<br>  protected _balance: number = 100;<br><br>  // Setter to allow deposits with validation<br>  set deposit(amount: number) {<br>    if (amount <= 0) {<br>      console.log('Deposit amount must be positive.');<br>      return;<br>    }<br>    console.log(`Setter called: adding $${amount} to balance.`);<br>    this._balance += amount;<br>  }<br><br>  get balance() {<br>    return this._balance;<br>  }<br>}<br><br>const acc = new BankAccount();<br>console.log(acc.balance); // 100<br><br>acc.deposit = 50; // Setter called: adding $50 to balance.<br>console.log(acc.balance); // 150<br><br>acc.deposit = -20; // Deposit amount must be positive.<br>console.log(acc.balance); // 150 (unchanged)</code></pre><br><b>🔄 Analogy:</b> Like depositing money into a bank ATM — you put in the amount, but the machine handles where it goes."
"🔒 <b>Why use <code>get</code> and <code>set</code> instead of public methods?</b>","<b>🧠 Emotional Hook:</b> Wouldn't it feel smoother to open your curtains instead of using a remote switch every time?<br><br><b>📘 Explanation:</b> Getters and setters make code cleaner and more natural to use, like accessing properties — but with the safety and control of methods.<br><br><b>💻 Example:</b><br><pre><code>class BankAccount {<br>  protected _balance: number = 100;<br><br>  get balance() {<br>    return this._balance;<br>  }<br><br>  set deposit(amount: number) {<br>    if (amount <= 0) {<br>      console.log('Deposit must be positive');<br>      return;<br>    }<br>    this._balance += amount;<br>  }<br><br>  // Traditional methods for comparison<br>  addDeposit(amount: number) {<br>    if (amount <= 0) {<br>      console.log('Deposit must be positive');<br>      return;<br>    }<br>    this._balance += amount;<br>  }<br><br>  getBalance() {<br>    return this._balance;<br>  }<br>}<br><br>const acc = new BankAccount();<br><br>// Using getters/setters (property-like syntax)<br>acc.deposit = 100;<br>console.log(acc.balance);<br><br>// Using traditional methods (explicit method calls)<br>acc.addDeposit(50);<br>console.log(acc.getBalance());</code></pre><br><b>🔄 Analogy:</b> Like smart home devices — behind the scenes it’s complex, but you just tap a button."
"🎯 <b>What's the difference between <code>balance</code> and <code>_balance</code>?</b>","<b>🧠 Emotional Hook:</b> Picture a museum: the artwork is visible to guests, but only curators can touch it.<br><br><b>📘 Explanation:</b> <code>_balance</code> is the protected internal data. <code>balance</code> (getter) safely exposes that data to the outside world.<br><br><b>💻 Example:</b><br><pre><code>class BankAccount {<br>  // Protected property holding the actual value<br>  protected _balance: number = 500;<br><br>  // Getter to provide read-only access externally<br>  get balance(): number {<br>    return this._balance;<br>  }<br>}<br><br>const acc = new BankAccount();<br><br>console.log(acc.balance);  // 500 (read via getter)<br><br>// acc._balance = 1000; // Error: Property '_balance' is protected</code></pre><br><b>🔄 Analogy:</b> Like a protective glass over a cake — you can see it, but can’t poke it directly!"
"📏 <b>What does <code>static</code> mean in TypeScript?</b>","<b>🧠 Emotional Hook:</b> Imagine a classroom whiteboard — shared by all students, not owned by one.<br><br><b>📘 Explanation:</b> A <code>static</code> property or method belongs to the class itself, not to instances. All objects share the same static value.<br><br><b>💻 Example:</b><br><pre><code>class Counter {<br>  // Static property to track count shared by all instances<br>  static count: number = 0;<br><br>  // Static method to increment and return count<br>  static increment(): number {<br>    Counter.count++;<br>    console.log(`Count incremented to: ${Counter.count}`);<br>    return Counter.count;<br>  }<br><br>  // Instance method to show instance count, if needed<br>  showInstanceCount() {<br>    console.log(`Instance method can't access static count directly.`);<br>  }<br>}<br><br>Counter.increment(); // Count incremented to: 1<br>Counter.increment(); // Count incremented to: 2<br><br>const c1 = new Counter();<br>c1.showInstanceCount(); // Instance method can't access static count directly</code></pre><br><b>🔄 Analogy:</b> Like a scoreboard in a stadium — everyone sees the same score, no matter where they sit!"
"👯 <b>Can each object have its own <code>static</code> value?</b>","<b>🧠 Emotional Hook:</b> Can different TV remotes show different time if they're all showing the clock from the same cable box?<br><br><b>📘 Explanation:</b> No! Static values are **shared** across all instances — changing one changes it for all.<br><br><b>💻 Example:</b><br><pre><code>class Counter {<br>  static count: number = 0;<br><br>  static increment() {<br>    return ++Counter.count;<br>  }<br>}<br><br>Counter.increment(); // 1<br>Counter.increment(); // 2<br><br>const c1 = new Counter();<br>const c2 = new Counter();<br><br>// Even though c1 and c2 are different objects, static count is shared<br>console.log(Counter.count); // 2<br>console.log(c1.constructor['count']); // 2<br>console.log(c2.constructor['count']); // 2</code></pre><br><b>🔄 Analogy:</b> Like a shared Google Doc — all changes are instantly visible to everyone."
"🚫 <b>Why can't we access <code>static</code> methods via instances?</b>","<b>🧠 Emotional Hook:</b> You don’t ask your clone for a family name — you ask the family itself!<br><br><b>📘 Explanation:</b> Static members exist on the class, not on objects. That’s why you must use <code>ClassName.method()</code> instead of <code>object.method()</code>.<br><br><b>💻 Example:</b><br><pre><code>class Counter {<br>  static increment() {<br>    console.log('Static increment method called.');<br>  }<br>}<br><br>const c = new Counter();<br><br>// ❌ This will cause an error or be undefined:<br>// c.increment(); // Error: Property 'increment' does not exist on type 'Counter'<br><br>// ✅ Correct usage:<br>Counter.increment(); // Static increment method called.</code></pre><br><b>🔄 Analogy:</b> Like the rules of chess — you ask the book, not the pieces."
"🧠 <b>When should you use <code>static</code> in real projects?</b>","<b>🧠 Emotional Hook:</b> Ever used a calculator app that works the same for every user?<br><br><b>📘 Explanation:</b> Use <code>static</code> when the data or behavior is common across all instances — like counters, utility functions, config settings.<br><br><b>💻 Example:</b><br><pre><code>class Utils {<br>  // Static method accessible without creating an instance<br>  static greet(name: string): string {<br>    return `Hello, ${name}! Welcome to the app.`;<br>  }<br><br>  // Static constant, shared config<br>  static readonly MAX_USERS = 1000;<br>}<br><br>console.log(Utils.greet('Sabbir')); // Hello, Sabbir! Welcome to the app.<br>console.log(`Max users allowed: ${Utils.MAX_USERS}`);</code></pre><br><b>🔄 Analogy:</b> Like a shared microwave in an office — everyone uses the same one."
"Question","Answer"
"🧠 <b>What is Polymorphism in TypeScript?</b>","<b>🎯 Emotional Hook:</b> Imagine one word — 'play' — meaning different things to a child, a musician, and a footballer.<br><br><b>📘 Definition:</b> Polymorphism allows different classes to define methods with the same name but different behaviors. It's like many shapes sharing the same interface but acting differently.<br><br><b>💻 Example:</b><br><pre><code>class Person { getSleep() { console.log('8 hours'); } }<br>class Student extends Person { getSleep() { console.log('7 hours'); } }<br>class Developer extends Person { getSleep() { console.log('6 hours'); } }<br><br>const logSleep = (p: Person) => p.getSleep();</code></pre><br><b>🔄 Analogy:</b> Like different instruments playing the same note — each sounds unique but follows the same musical key."
"🎭 <b>Why use Polymorphism?</b>","<b>✨ Emotional Hook:</b> Wouldn’t it be magical to call one method and get behavior based on who’s responding?<br><br><b>📘 Explanation:</b> Polymorphism helps in writing flexible and reusable code. You can call the same method on different types of objects without knowing their exact class.<br><br><b>💻 Example:</b><br><pre><code>getSleepingHours(new Student());<br>getSleepingHours(new Developer());</code></pre><br>This works because both are `Person` subclasses with their own `getSleep()` method.<br><br><b>🔄 Analogy:</b> Like using a single 'speak' command for different animals — dogs bark, cats meow, birds chirp."
"🟦 <b>Polymorphism with Shapes — What’s the Benefit?</b>","<b>🧠 Emotional Hook:</b> What if you could calculate area for ANY shape with just one function?<br><br><b>📘 Explanation:</b> The `Shape` base class defines a `getArea()` method. Subclasses like `Circle` and `Rectangle` override it to provide specific calculations.<br><br><b>💻 Example:</b><br><pre><code>class Circle extends Shape {<br>  getArea() { return Math.PI * r * r; }<br>}<br>class Rectangle extends Shape {<br>  getArea() { return height * width; }<br>}<br>getShapeArea(new Circle(10));</code></pre><br><b>🔄 Analogy:</b> Like different people filling out the same form — same interface, unique answers."
"🔁 <b>How does method overriding enable polymorphism?</b>","<b>🎯 Emotional Hook:</b> Think of siblings with the same parent — each with their own way of celebrating their birthday!<br><br><b>📘 Explanation:</b> Method overriding allows child classes to redefine a method inherited from a parent class. This lets polymorphism work, giving you dynamic behavior at runtime.<br><br><b>💻 Example:</b><br><pre><code>class Shape { getArea(): number { return 0; } }<br>class Circle extends Shape { getArea(): number { return Math.PI * r * r; } }</code></pre><br><b>🔄 Analogy:</b> Like customizing a family recipe — same dish name, different flavors."
"🧠 <b>What is Abstraction in TypeScript?</b>","<b>🎯 Emotional Hook:</b> Imagine using a microwave — you press buttons without knowing how the electricity heats your food!<br><br><b>📘 Definition:</b> Abstraction is the concept of hiding complex implementation details and showing only the necessary features.<br><br><b>💡 Use cases:</b> Create blueprints (interfaces or abstract classes) that describe how things should behave, not how they work.<br><br><b>🔄 Analogy:</b> Like using a TV remote — you only need to know the buttons, not the circuitry inside."
"🚗 <b>What is an Interface?</b>","<b>🎯 Emotional Hook:</b> Think of an interface like a contract — it says what must be done, but not how!<br><br><b>📘 Explanation:</b> An interface in TypeScript defines a set of methods and properties a class must implement. It’s all about the 'what', not the 'how'.<br><br><b>💻 Example:</b><br><pre><code>interface Vehicle {<br>  startEngine(): void;<br>  stopEngine(): void;<br>  move(): void;<br>}<br><br>class Car implements Vehicle {<br>  startEngine() { console.log('Starting engine'); }<br>  stopEngine() { console.log('Stopping engine'); }<br>  move() { console.log('Moving car'); }</code></pre><br><b>🔄 Analogy:</b> Like a job posting — it lists the responsibilities, but not how you’ll complete them."
"🚙 <b>What is an Abstract Class?</b>","<b>🎯 Emotional Hook:</b> Imagine your favorite board game — the rulebook sets the structure, but each player can play their own way.<br><br><b>📘 Explanation:</b> An abstract class can have both abstract methods (no implementation) and normal methods (with implementation). It’s a partially completed blueprint.<br><br><b>💻 Example:</b><br><pre><code>abstract class Car {<br>  abstract startEngine(): void;<br>  move() { console.log('Moving'); }<br>}<br>class Toyota extends Car {<br>  startEngine() { console.log('Starting Toyota'); } }</code></pre><br><b>🔄 Analogy:</b> Like a parent recipe that must be customized by each child — “make curry,” but you decide the spices!"
"🤔 <b>Interface vs Abstract Class — What’s the Difference?</b>","<b>🎯 Emotional Hook:</b> Interfaces are like rules. Abstract classes are like templates with some rules already filled in.<br><br><b>📘 Summary:</b><br><ul><li>✅ Interface: Only declares method signatures, no code.</li><li>✅ Abstract class: Can have both abstract and implemented methods.</li><li>✅ A class can implement multiple interfaces but can only extend one abstract class.</li></ul><br><br><b>💻 Example:</b><br><pre><code>interface Flyable { fly(): void; }<br>abstract class Bird { abstract fly(): void; sing() { console.log('Chirp'); } }</code></pre><br><b>🔄 Analogy:</b> Interface = rulebook; Abstract Class = partly built house you must complete."
Question,Answer
"🔐 What are Access Modifiers in TypeScript?","<b>🎯 Emotional Hook:</b> Ever wondered why you can’t peek inside your teacher’s gradebook, but you can see your own report card?<br><br><b>📘 Definition:</b> Access modifiers control where class properties and methods can be accessed from:<br><ul><li><code>public</code>: Accessible from anywhere</li><li><code>private</code>: Accessible only inside the class</li><li><code>protected</code>: Accessible inside the class and its subclasses</li></ul><br><b>🔄 Analogy:</b> 1. Public = A public park — open to everyone.<br>2. Protected = Family-only hallway — shared among relatives.<br>3. Private = Your bedroom — just for you!"
"🧭 What does <code>public</code> mean?","<b>🎯 Emotional Hook:</b> Imagine a public park where everyone is welcome to stroll.<br><br><b>📘 Explanation:</b> Members marked <code>public</code> can be accessed anywhere — inside or outside the class.<br><br><b>💻 Example:</b><br><pre><code>class BankAccount {<br>  public name: string;<br>  constructor(name: string) { this.name = name; }<br>}<br>const account = new BankAccount('Alice');<br>console.log(account.name); // ✅ Works anywhere</code></pre><br><b>🔄 Analogy:</b> Like a bustling town square — free and open to all!"
"🏠 What does <code>private</code> mean?","<b>🎯 Emotional Hook:</b> Think of your phone’s password — only you know it!<br><br><b>📘 Explanation:</b> <code>private</code> members can only be accessed inside the class itself — not from subclasses or instances.<br><br><b>💻 Example:</b><br><pre><code>class BankAccount {<br>  private balance: number = 100;<br>  private getBalance() { return this.balance; }<br>}<br>const acc = new BankAccount();<br>// acc.getBalance(); ❌ Error</code></pre><br><b>🔄 Analogy:</b> Like your personal diary — locked and hidden just for you."
"👨‍👧 What does <code>protected</code> mean?","<b>🎯 Emotional Hook:</b> Like a secret family recipe passed down generations.<br><br><b>📘 Explanation:</b> <code>protected</code> members are accessible inside the class and its subclasses — but not outside.<br><br><b>💻 Example:</b><br><pre><code>class BankAccount {<br>  protected _balance: number = 100;<br>}<br>class StudentAccount extends BankAccount {<br>  printBalance() { console.log(this._balance); } // ✅ Accessible here<br>}<br>const acc = new StudentAccount();<br>// acc._balance; ❌ Error</code></pre><br><b>🔄 Analogy:</b> Like a family vault — shared among relatives but hidden from outsiders."
"🛡️ What is <code>readonly</code> in TypeScript?","<b>🎯 Emotional Hook:</b> Imagine engraving your name on a trophy — once etched, it can't be changed!<br><br><b>📘 Definition:</b> <code>readonly</code> makes a property immutable after initialization — either where it’s declared or inside the constructor.<br><br><b>💻 Example:</b><br><pre><code>class User {<br>  public readonly id: number;<br>  constructor(id: number) {<br>    this.id = id;<br>  }<br>}<br>const user = new User(123);<br>// user.id = 456; ❌ Error</code></pre><br><b>🔄 Analogy:</b> Like a sealed envelope — the address is fixed once sent!"
"🏗️ What is Constructor Shorthand in TypeScript?","<b>🎯 Emotional Hook:</b> Want to do less work but still get full credit?<br><br><b>📘 Definition:</b> You can declare and initialize class properties directly in the constructor parameters using access modifiers.<br><br><b>💻 Example:</b><br><pre><code>class Product {<br>  constructor(public name: string, private price: number) {}<br>}<br>const pen = new Product('Blue Pen', 5);</code></pre><br><b>🔄 Analogy:</b> Like ordering a combo meal — simpler, faster, same delicious result!"
"🎯 What is Encapsulation?","<b>🎯 Emotional Hook:</b> Ever used a smartphone without knowing how it works inside? That’s encapsulation!<br><br><b>📘 Definition:</b> Encapsulation hides internal details and exposes only what’s necessary for interaction.<br><br><b>💻 Example:</b><br><pre><code>class BankAccount {<br>  private balance: number = 100;<br>  public deposit(amount: number) { this.balance += amount; }<br>}<br>const acc = new BankAccount();<br>acc.deposit(50); // ✅ Safe interaction</code></pre><br><b>🔄 Analogy:</b> Like a vending machine — you press a button, get a snack, but never see the mechanics inside."
"🧠 What is Abstraction?","<b>🎯 Emotional Hook:</b> When you drive a car, do you need to know how the engine works? Nope — that’s abstraction!<br><br><b>📘 Definition:</b> Abstraction hides complex implementation details, showing only essential features.<br><br><b>💻 Example (interface):</b><br><pre><code>interface Vehicle { move(): void; }<br>class Car implements Vehicle { move() { console.log('Moving'); } }</code></pre><br><b>💻 Example (abstract class):</b><br><pre><code>abstract class Animal { abstract makeSound(): void; }<br>class Dog extends Animal { makeSound() { console.log('Woof'); } }</code></pre><br><b>🔄 Analogy:</b> Like a TV remote — you know what each button does, not how the circuits inside work!"
